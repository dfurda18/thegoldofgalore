@tool
## Either a Sprite2D or Polygon2D. Controlled by the AnimationPlayer and RemoteDrawing
extends Node2D
#class_name Drawing

#const Composite = preload("Composite.gd")
#const MotionCharacter = preload("MotionCharacter.gd")

## Whether or not a collision shape should be generated for this drawing
@export var has_associated_collider: bool = true:
	set(value):
		if has_associated_collider == value:
			return
		# Refresh the shapes
		has_associated_collider = value
		#visibility_changed.emit()
		var parent = composite.get_node_or_null("..") as TBG.MotionCharacter
		if parent:
			parent.update_colliders()

# Custom scaling needs to aggregate current texture_scale with scale from animations.
var drawing_scale := Vector2(1, 1):
	set(value):
		drawing_scale = value
		update_scale()

var base_scale := Vector2(1, 1):
	set(value):
		base_scale = value
		update_scale()

# Assign texture based on skin_id and texture_id - needs to work for both sprites and polygons.
var skin_id: int
var texture_id: String:
	set(value):
		if value == texture_id:
			return
		texture_id = value
		update_texture()

# Sorting order.
var node_order: int
var position_z: int = 0:
	set(value):
		if value == position_z:
			return
		position_z = value
		if composite != null:
			composite.update_node_order()

var pivot := Vector2(0, 0):
	set(value):
		if pivot == value:
			return
		pivot = value
		update_texture()

# Helper Getters

var composite: TBG.Composite:
	get:
		if composite == null:
			composite = get_node_or_null("..") as TBG.Composite
		return composite

var _sprite: Sprite2D:
	get:
		if _sprite == null:
			_sprite = get_node_or_null(".") as Sprite2D
		return _sprite

var _polygon: Polygon2D:
	get:
		if _polygon == null:
			_polygon = get_node_or_null(".") as Polygon2D
		return _polygon

func _ready():
	update_texture()

func check_visibility():
	var is_visible = composite.config.id_to_visibility.get(name)
	if is_visible == null:
		return
	visible = is_visible

# Movement detection for cutters.
signal local_transform_changed()
func _notification(what):
	pass

func _get_property_list():
	if TBG.currently_saving:
		# Gets rid of most garbage data generated by animations
		transform = Transform2D()
		scale = drawing_scale
		# Only disable if the parent can renable (if needed) later and not a cutter
		if not self is TBG.Cutter and composite:
			var node = composite.get_node_or_null("..")
			if node is TBG.MotionCharacter:
				use_parent_material = false
				if node.shader_material:
					material = null
		
		#if _sprite:
			#_sprite.offset = Vector2.ZERO
			#_sprite.texture = null
		if _polygon:
			_polygon.offset = Vector2.ZERO
			_polygon.texture = null
			_polygon.polygon = PackedVector2Array()
			_polygon.uv = PackedVector2Array()
			_polygon.bones = []
	
	# this is all that data that shouldn't be saved since it is controlled by animations
	return [
		{
			"name": "drawing_scale",
			"type": TYPE_VECTOR2,
			"usage": PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NO_INSTANCE_STATE,
		},
		{
			"name": "base_scale",
			"type": TYPE_VECTOR2,
			"usage": PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NO_INSTANCE_STATE,
		},
		{
			"name": "skin_id",
			"type": TYPE_INT,
			"usage": PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NO_INSTANCE_STATE,
		},
		{
			"name": "texture_id",
			"type": TYPE_STRING,
			"usage": PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NO_INSTANCE_STATE,
		},
		{
			"name": "node_order",
			"type": TYPE_INT,
			"usage": PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NO_INSTANCE_STATE,
		},
		{
			"name": "position_z",
			"type": TYPE_INT,
			"usage": PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NO_INSTANCE_STATE,
		},
		{
			"name": "pivot",
			"type": TYPE_VECTOR2,
			"usage": PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NO_INSTANCE_STATE,
		},
	]


# Helper functions

func update_scale() -> void:
	scale = base_scale * drawing_scale


func update_texture() -> void:
	if composite == null:
		return
	if _sprite != null:
		if texture_id.length() == 0:
			_sprite.texture = null;
		else:
			var texture_info = composite.config.id_to_texture.get(texture_id)
			
			if texture_info == null:
				_sprite.texture = null
			else:
				_sprite.offset = texture_info.offset + pivot * Vector2(-1, 1) / texture_info.scale
				_sprite.texture = texture_info.texture
				drawing_scale = texture_info.scale
	elif _polygon != null:
		if texture_id.length() == 0:
			_polygon.texture = null
			_polygon.polygon = []
		else:
			var texture_info = composite.config.id_to_texture.get(texture_id)
			if texture_info == null:
				_polygon.texture = null
				_polygon.polygon = []
			else:
				_polygon.texture = texture_info.texture
				var node_name = self.get_name()
				var texture_name = texture_info.texture.get_name()
				var data = composite.config.node_to_texture_to_polygon_data[node_name][texture_name]
				
				_polygon.uv = data.uv;
				_polygon.polygon = data.positions;
				
				_polygon.clear_bones()
				for bone in data.bones:
					_polygon.add_bone(bone, data.bones[bone])
	check_visibility()
